from __future__ import annotations
from abc import ABC, abstractmethod
import jax.numpy as jnp

from jVMC_exp.vqs import NQS
from jVMC_exp.sharding_config import sharded, DEVICE_SPEC
from jVMC_exp.operator.base import AbstractOperator

class Operator(AbstractOperator):
    def __init__(self, ldim):
        self._ldim = ldim
        self._is_compiled = False
        self._scale = 1

    @property
    def ldim(self):
        return self._ldim
    
    def __add__(self, other) -> Operator:
        if isinstance(other, (int, float, complex)):
            # TODO: Since I don't know the total dim of the Hilbert space this is not doable
            raise NotImplementedError 
        elif isinstance(other, Operator):
            return self._create_composite(self, other, 'sum')
        else:
            raise NotImplemented
        
    def __radd__(self, other) -> Operator:
        if isinstance(other, (int, float, complex)):
            # TODO: Same as previous todo
            raise NotImplementedError
        else:
            raise NotImplemented
        
    def __neg__(self) -> Operator:
        return self._create_scaled(self, -1)
    
    def __sub__(self, other) -> Operator:
        if isinstance(other, (int, float, complex)):
            # TODO: Same as previous todo
            raise NotImplementedError
        elif isinstance(other, Operator):
            return self._create_composite(self, -other, 'sum')
        else:
            raise NotImplemented
        
    def __rsub__(self, other) -> Operator:
        if isinstance(other, (int, float, complex)):
            # TODO: Same as previous todo
            raise NotImplementedError
        else:
            raise NotImplemented
        
    def __mul__(self, other) -> Operator:
        if isinstance(other, (int, float, complex)) or callable(other):
            return self._create_scaled(self, other)
        elif isinstance(other, Operator):
            return self._create_composite(self, other, 'mul')
        else:
            raise NotImplemented
        
    def __rmul__(self, other) -> Operator:
        if isinstance(other, (int, float, complex)) or callable(other):
            return self._create_scaled(self, other)
        else:
            raise NotImplemented
        
    def get_O_loc(self, s, psi: NQS, *, logPsiS=None, **kwargs):
        logPsiS = psi(s) if logPsiS is None else logPsiS

        s_p, matEls = self.get_conn_elements(s, psi.batchSize, **kwargs)
        logPsiS_p = psi._act_on_non_zero(
            s_p.reshape((-1,) + psi.sampleShape),
            matEls.flatten(),
            parameters=psi.parameters,
            batch_size=psi.batchSize
        ).reshape(matEls.shape)

        return self._get_O_loc(logPsiS, logPsiS_p, matEls, batch_size=psi.batchSize) 
    
    @sharded(use_vmap=False)
    def _get_O_loc(self, logPsiS, logPsiS_p, matEls, *, batch_size):
        return jnp.sum(jnp.exp(logPsiS_p - logPsiS[:, None]) * matEls, axis=1)

    def get_conn_elements(self, s, batch_size, **kwargs):
        if not self._is_compiled:
            self._compile()

        return self._get_conn_elements_sh(s, batch_size=batch_size, **kwargs)
    
    @sharded(out_specs=(DEVICE_SPEC, DEVICE_SPEC))
    def _get_conn_elements_sh(self, s, *, batch_size, **kwargs):
        return  self._get_conn_elements(s, kwargs)
        
    @abstractmethod
    def _compile(self):
        """
        Compile the operator into JAX arrays for efficient computation.
        """
        pass
    
    @abstractmethod
    def _get_conn_elements(self, s, kwargs):
        """
        Compute the connected configurations and corresponding matrix elements
        generated by the action of an operator on a given input configuration.

        This method must return:
        (i) all non-diagonal connected configurations with shape (NumConnectedElements, SampleShape),
        (ii) their associated matrix elements with shape (SampleShape,), and
        (iii) the total diagonal contribution.

        Parameters
        ----------
        s : Single input configuration 

        kwargs : Auxiliary parameters required to compute operator prefactors.

        Returns
        -------
        s_p_non_diag : Array of configurations connected to `s`.

        mat_els_non_diag : One-dimensional array of complex matrix elements corresponding
            to each configuration in `s_p_non_diag`.

        mat_els_diag : Scalar equal to the sum of all diagonal matrix elements.
        """
        pass
    
    @classmethod
    @abstractmethod
    def _create_composite(cls, O_1, O_2, label):
        pass

    @classmethod
    @abstractmethod
    def _create_scaled(cls, O, scalar):
        pass